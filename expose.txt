
Prozesskalküle erlauben eine formale, abstrakte Beschreibung von nebenläufigen und verteilten Systemen, die mithilfe algebraischer Gesetze umgeformt und analysiert werden können. Sollen so beschriebene Prozesse jedoch ihrer Semantik getreu implementiert und verteilt ausführbar gemacht werden, ergeben sich oft Probleme. So erfordern sowohl im synchronen als auch asynchronen Pi-Kalkül vorhandene Kommunikationsprimitive das Lösen komplexer Konsensprobleme, da Kanäle sich keinem eindeutigen Ort befinden.
Sehr gut verteilen lässt sich hingegen der Join-Kalkül, bei dem sich mehrere Empfänger auf dem selben Kanal immer am selben Ort befinden müssen. In seiner grundlegenden Definition ermöglicht er, asynchrone Nachrichten zu senden und mithilfe von Join-Patterns zu empfangen. Es existieren jedoch Erweiterungen wie Möglichkeiten zur synchronen Kommunikation, die mithilfe von Continuation-Passing auf die grundlegende Semantik zurückgeführt werden kann, explizite Verwaltung von Locations sowie eine Typtheorie im Stil von ML.
Dadurch eignet er sich zur Einbettung in Programmiersprachen. Es existieren bereits Implementierungen in OCaml (JoCaml) und Scala (Chymyst). Chymyst ist jedoch nicht verteilt und profitiert so nicht von der Verteilbarkeit des Join-Kalküls. Bei JoCaml handelt es sich um eine Erweiterung des Ocaml-Compilers, die jedoch ...

Für eine verteilte Implementierung des Join-Kalküls bietet es sich an, auf existierenden Möglichkeiten zur verteilten Kommunikation aufzubauen. So stellt zum Beispiel eine Implementierung des Aktorenmodells bereits viel Funktionalität zur Verfügung, so dass eine direkte Auseinanderetzung mit den Details des Netzwerkstacks erspart bleibt. Nötig wäre somit nur eine auf hoher Abstraktionsebene stattfindende Übersetzung von Konstrukten des Join-Kalküls in das Aktorenmodell.
Im Rahmen dieser Bachelorarbeit soll die Möglichkeit einer solchen Übersetzung überprüft und darauf aufbauend ein Prototyp einer verteilten Implementierung entwickelt werden. Dazu ist zuerst die Auseinandersetzung mit der Semantik des Join-Kalküls und des Aktorenmodells notwendig, die in einer formalen Beschreibung der Übersetzung resultieren soll. Diese dient dann als Grundlage der Implementierung auf Basis des Akka-Frameworks in Scala. Hier ist zu klären, welche Vor- und Nachteile eine Umsetzung als Scala-Library, eine externe Kompilation zu Scala-Quellcode oder auch eine Integration in den Compiler bieten.

