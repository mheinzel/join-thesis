\section{The \JoinCalc}

\TODO{2cm}{short introduction? idea?}


\subsubsection{Syntax}

We use \joincalc as described by Fournet et al.
\cite{fournet_calculus_1996}.
Assuming an infinite set of channel names
$ \mathcal{N} = \{ x, y, z, u, v, \kappa, \ldots \} $,
we use
$ \tilde{x}, \tilde{y}, \ldots $
for tuples of names
and define the syntax as follows.

% turn into figure again?
% left-align explanations?
\begin{align}
  \tag*{\textbf{processes}}
  \\
  P, Q
  \grmr \jsnd{x}{\tilde{v}}   \tag*{emission of $\tilde{v}$ on $x$}
  \altn \nonumber \jdef{D}{P} \tag*{definition of D in P}
  \altn P \jpar Q             \tag*{parallel composition}
  \altn \jnullproc            \tag*{empty process}
  \\ \nonumber
  \\
  \tag*{\textbf{definitions}}
  \\
  D, E
  \grmr \jrct{J}{P} \tag*{elementary clause}
  \altn D \jcon E   \tag*{simultaneous definitions}
  \altn \jnulldef   \tag*{empty definition}
  \\ \nonumber
  \\
  \tag*{\textbf{join-patterns}}
  \\
  J, K
  \grmr \jrcv{x}{\tilde{v}} \tag*{reception of $\tilde{v}$ on x}
  \altn J \jpat K           \tag*{composed join-pattern}
\end{align}

% TODO: remove reference to pi if not explained here
Readers familiar with \asyncpicalc
\cite{honda_object_1991}
\cite{boudol_asynchrony_1992}
will recognize emission,
parallel composition and the empty process, but miss the usual constructs for
defining new channels, reception and replication.
All these concerns are covered by a single primitive,
$ \jdef{D}{P} $.

\TODO{3cm}{explain def (scopes)}
% check literature

Note that all received names in a join-pattern must be distinct,
making both patterns
$ \jrcv{x}{u,u} $ and
$ \jrcv{x}{u} \jpat \jrcv{y}{u} $
invalid.


\begin{alignat*}{2}
  & \rv{\jrcv{x}{\tilde{v}}} & &= \{ u \in \tilde{v} \} \\
  & \rv{J \jpat K}           & &= \rv{J} \uplus \rv{K} \\
  \\
  & \dv{\jrcv{x}{\tilde{v}}} & &= \{ x \} \\
  & \dv{J \jpat K}           & &= \dv{J} \cup \dv{K} \\
  \\
  & \dv{\jrct{J}{P}}         & &= \dv{J} \\
  & \dv{D \jcon E}           & &= \dv{D} \cup \dv{E} \\
  & \dv{\jnulldef}           & &= \emptyset \\
  \\
  & \fv{\jrct{J}{P}}         & &= \dv{J} \cup (\fv{P} - \rv{J}) \\
  & \fv{D \jcon E}           & &= \fv{D} \cup \fv{E} \\
  & \fv{\jnulldef}           & &= \emptyset \\
  \\
  & \fv{\jsnd{x}{v}}         & &= \{ x \} \cup \{ u \in \tilde{v} \} \\
  & \fv{\jdef{D}{P}}         & &= (\fv{P} \cup \fv{D}) - \dv{D} \\
  & \fv{P \jpat Q}           & &= \fv{P} \cup \fv{Q} \\
  & \fv{\jnullproc}          & &= \emptyset \\
\end{alignat*}


\subsubsection{Semantics}

% TODO: use reduction semantics instead of CHAM?
The semantics of \joincalc is described using the reflexive chemical abstract
machine (RCHAM) \cite{fournet_reflexive_1996}.
A RCHAM configuration
$ \rchamcnf{\mathcal{R}}{\mathcal{M}} $
consists of a multiset of active definitions $\mathcal{R}$,
called ``reactions",
and a multiset of active processes $\mathcal{M}$,
called ``molecules".

There are multiple reversible heating/cooling rules $\rchamheating$,
corresponding to the structural congruence between processes,
and a single reduction rule $\rchamreduction$.
In each of these rules, there is an implicit unchanged context of reactions and
molecules which we omit for brevity.

\begin{align*}
  \rchamequ{str-join}{
    \rchamcnf*{}{P \jpar Q}
  }{
    \rchamcnf*{}{P, Q}
  }
  \\
  \rchamequ{str-null}{
    \rchamcnf*{}{\jnullproc}
  }{
    \rchamcnf*{}{}
  }
  \\
  \rchamequ{str-and}{
    \rchamcnf*{D \jcon E}{}
  }{
    \rchamcnf*{D, E}{}
  }
  \\
  \rchamequ{str-nodef}{
    \rchamcnf*{\jnulldef}{}
  }{
    \rchamcnf*{}{}
  }
  \\
  \rchamequ{str-def}{
    \rchamcnf*{}{\jdef{D}{P}}
  }{
    \rchamcnf*{D\sigma_{\opdv}}{P\sigma_{\opdv}}
  }
  \\
  \\
  \rchamred{red}{
    \rchamcnf*{\jrct{J}{P}}{J\sigma_{\oprv}}
  }{
    \rchamcnf*{\jrct{J}{P}}{P\sigma_{\oprv}}
  }
\end{align*}

In (str-dev), the substitution $\sigma_{\opdv}$ instantiates the defined
variables $\dv{D}$ to distinct, fresh names that are not free in any reaction
or molecule in the configuration.
In (red), $\sigma_{\oprv}$ simply substitutes the received variables $\rv{J}$.
Note that (red) makes use of the syntactic similarity between join-patterns
and parallel emission of messages in processes.

\TODO{2cm}{explain rules?}
% note replication etc?

To obtain a reduction relation $\joinreduction$
on processes (instead of RCHAM configurations),
we can define for any two processes P and P':
\begin{equation*}
  P \joinreduction P'
  \ \ \textbf{iff} \ \ 
  \rchamcnf{\emptyset}{P}
  \rchamheating^*\rchamreduction\rchamheating^*
  \rchamcnf{\emptyset}{P'}
\end{equation*}

% TODO: macro for examples?
Let us give an example:

\begin{align*}
  &&\rchamcnfset*
    {}
    {\jdef
      {\jrct{\jrcv{x}{u} \jpat \jrcv{y}{v}}{P}}
      {\jsnd{x}{a} \jpar \jsnd{x}{b} \jpar \jsnd{y}{c}}}
  \\
  \rchamheating\ \tag{str-def}
  &&\rchamcnfset*
    {\jrct{\jrcv{x}{u} \jpat \jrcv{y}{v}}{P}}
    {\jsnd{x}{a} \jpar \jsnd{x}{b} \jpar \jsnd{y}{c}}
  \\
  \rchamheating\ \tag{str-join}
  &&\rchamcnfset*
    {\jrct{\jrcv{x}{u} \jpat \jrcv{y}{v}}{P}}
    {\jsnd{x}{a}, \jsnd{x}{b} \jpar \jsnd{y}{c}}
  \\
  \rchamreduction \tag{red}
  &&\rchamcnfset*
    {\jrct{\jrcv{x}{u} \jpat \jrcv{y}{v}}{P}}
    {\jsnd{x}{a}, P\substitution{\subst{b}{u}, \subst{c}{v}}}
  \\
  \rchamheating\ \tag{str-join}
  &&\rchamcnfset*
    {\jrct{\jrcv{x}{u} \jpat \jrcv{y}{v}}{P}}
    {\jsnd{x}{a} \jpar P\substitution{\subst{b}{u}, \subst{c}{v}}}
  \\
  \rchamheating\ \tag{str-def}
  &&\rchamcnfset*
    {}
    {\jdef
      {\jrct{\jrcv{x}{u} \jpat \jrcv{y}{v}}{P}}
      {\jsnd{x}{a} \jpar P\substitution{\subst{b}{u}, \subst{c}{v}}}}
\end{align*}

and thus

\begin{equation*}
  \jdef
    {\jrct{\jrcv{x}{u} \jpat \jrcv{y}{v}}{P}}
    {\jsnd{x}{a} \jpar \jsnd{x}{b} \jpar \jsnd{y}{c}}
  \ \joinreduction\ 
  \jdef
    {\jrct{\jrcv{x}{u} \jpat \jrcv{y}{v}}{P}}
    {\jsnd{x}{a} \jpar P\substitution{\subst{b}{u}, \subst{c}{v}}}
\end{equation*}

Note the non-determinism in receiving $b$ instead of $a$ on $x$.
Instead of
$ \jsnd{x}{a} \jpar P\substitution{\subst{b}{u}, \subst{c}{v}} $
we could also arrive at
$ \jsnd{x}{b} \jpar P\substitution{\subst{a}{u}, \subst{c}{v}} $.


\subsection{The \CoreJoinCalc}

The full calculus can be encoded in a fragment of itself, called core calculus
\cite{fournet_reflexive_1996}.
Since all of its processes are also valid processes in the full calculus,
it suffices to describe its semantics using the RCHAM as shown above,
only using the rules (str-join), (str-def) and (red).

\begin{align*}
  P, Q
  \grmr \jsnd{x}{u}
  \altn P \jpar Q
  \altn \jdef{\jrct{\jrcv{x}{u} \jpat \jrcv{y}{v}}{P}}{Q}
\end{align*}


\subsection{The \DistJoinCalc}

\TODO{2cm}{short explanation of idea \cite{fournet_calculus_1996}}

In addition to an infinite set of channel names
$ \mathcal{N} = \{ x, y, z, \kappa, \ldots \} $,
we now use an infinite set of location names
$ \mathcal{L} = \{ a, b, c, \ldots \} $.
These can also be sent and received, which means that values
$ u, v, \ldots $ in $ \jsnd{x}{\tilde{v}} $
can now be either channel or location names.
We extend the syntax of \joincalc by two new constructs.

\begin{align*}
  P, Q
  \grmr \dots
  \altn \jgo{b}{\kappa}
  \\ \\
  D, E
  \grmr \dots
  \altn \jloc{a}{D}{P}
\end{align*}

% TODO: explain what new constructs mean?
Also, we demand two additional syntactic restrictions:
Firstly, location $a$ can only be defined once in any definition $D$.
Secondly, channel $x$ may only appear in the join-patterns of one location.
These conditions make the following definitions invalid:

\begin{align*}
  &\jdef
    {\jloc{a}{D}{P} \jcon \jrct{\jloc{a}{E}{Q}}{R}}
    {S}
  \\
  &\jdef
    {\jloc{a}{\jrct{\jrcv{x}{u}}{P}}{Q}
     \jcon
     \jloc{b}{\jrct{\jrcv{x}{v}}{R}}{S}
     }
    {T}
\end{align*}

The semantics of the new constructs are defined using a distributed version
of the RCHAM, called DRCHAM.
We tag configurations with their location
$ \mathcal{L} = \{ \phi, \psi, \ldots \} $

$ \drchamcnf{\phi}{\mathcal{R}}{\mathcal{M}} $

\TODO{3.5cm}{explain DRCHAM\\
location tree\\
previous rules apply\\
(str-def gives fresh location names, too)}

Then we add three new rules for the two new syntactical constructs:
% TODO: which \phi ?

\begin{align*}
  \drchamequ{str-loc}{(a \ \text{frozen)}}{
    \drchamcnf{\phi}{\jloc{a}{D}{P}}{}
  }{
    \drchamcnf{\phi}{}{}
    \drchampar
    \drchamcnf{\phi a}{D}{P}
  }
  \\
  \drchamred{comm}{(x \in \dv{J})}{
    \drchamcnf{\phi}{}{\jsnd{x}{\tilde{v}}}
    \drchampar
    \drchamcnf{}{\jrct{J}{P}}{}
  }{
    \drchamcnf{\phi}{}{}
    \drchampar
    \drchamcnf{}{\jrct{J}{P}}{\jsnd{x}{\tilde{v}}}
  }
  \\
  \drchamred{move}{}{
    \drchamcnf{\phi}{\jloc{a}{D}{P \jpar \jgo{b}{\kappa}}}{}
    \drchampar
    \drchamcnf{\psi b}{}{}
  }{
    \drchamcnf{\phi}{}{}
    \drchampar
    \drchamcnf{\psi b}{\jloc{a}{D}{P \jpar \jsnd{\kappa}{}}}{}
  }
\end{align*}

\TODO{3cm}{conditions\\explain new rules}
% can dissolve new kind of definition as with str-def
% move emitted message to correct location
% migrate the current location
