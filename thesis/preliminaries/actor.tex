\section{The \ActorModel}

The notion of actors was first developed by Hewitt \cite{hewitt_universal_1973}
and later formalized by Agha \cite{agha_actors:_1986}
as a model of concurrent computation.
As described in \cite{agha_algebraic_2004},
a computational system in the \actormodel, called a \emph{configuration},
consists of a collection of concurrently executing actors
and a collection of messages in transit.
Each actor has a unique name (the \emph{uniqueness} property)
and a \emph{behavior},
and it communicates with other actors via asynchronous messages.
Actors are reactive in nature,
i.e. they execute only in response to messages receives.
An actor's behavior is deterministic in that its response to a message is
uniquely determined by the message contents.
Message delivery in the \actormodel is fair.
The delivery of a message can only be delayed
for a finite but unbounded amount of time.

An actor can perform three basic actions on receiving a message:
\begin{itemize}
  \item create a finite number of actors with universally fresh names
  \item send a finite number of messages
  \item assume a new behavior
\end{itemize}

In addition to the already mentioned \emph{uniqueness},
there are two other properties we should note:
First, actors do not disappear after processing a message
(the \emph{persistence} property).
Second,
actors cannot be created with well known names or names received in a message
(the \emph{freshness} property).

The description of a configuration also defines an interface
between the configuration and its environment,
which constrains interactions between the two.
An interface is a set of names, called the \emph{receptionist} set,
that contains the names of all actors in the configuration
that are visible to the environment.
The receptionist set may evolve during interactions,
as the messages that the configuration sends to the environment
may contain names of actors not currently in the receptionist set.


\subsection{\ActorPiCalc}

\TODO{2cm}{variant of \picalc that imposes type restrictions\\
  to provide a representation of the actor model in a formal process calculus}

Definition directly from \cite{agha_algebraic_2004}.

\subsubsection{Syntax}

We assume an infinite set of channel names
$ \mathcal{N} = \{u, v, w, x, y, z, \ldots\} $.
The set of actor configurations is defined by the following grammar.

\begin{align*}
  P, Q
  \grmr \anullproc
  \altn \amrcv{x}{y} . P
  \altn \amsnd{x}{y}
  \altn \anew{x}{P}
  \altn P \apar Q
  \altn \acse{x}{\aalt{y_1}{P_1}, \dots, \aalt{y_n}{P_n}}
  \altn \ains{B}{\tilde{x}}{\tilde{y}}
\end{align*}

The order of precedence among the constructs is the order in which they are
listed.

\TODO{3cm}{explain constructs\\
  (every inst requires a bevahior definition of form...)}


\subsubsection{Type System}

Not all syntactically well-formed configurations are valid actor configurations,
but we can enforce the actor properties by imposing a type system.

\TODO{1cm}{why ch() etc.? relaxed persistence}

% verbatim quote
We assume $\bot, * \notin \mathcal{N}$
and for $X \subset \mathcal{N}$
we define
$X^* = X \cup \{\bot, *\}$.
For $f : X \rightarrow X^*$
we define $f^* : X^* \rightarrow X^*$ as
$f^*(x) = f(x) $ for $ x \in X$ and
$f^*(\bot) = f^*(*) = \bot$.
A typing judgement is of the form
$\judgement{\rho}{f}{P}$,
where $\rho$ is the receptionist set of P,
and $f : \rho \rightarrow \rho^*$ is a temporary name mapping function
that relates actors in $P$ to the temporary names they have currently assumed.
\begin{itemize}
  \item $f(x) = \bot$ \dots
  \item $f(x) = *$ \dots
  \item $f(x) = y \notin \{\bot, *\}$ \dots
\end{itemize}

Properties:
\begin{itemize}
  \item $f(x) \neq x$ \dots
  \item \dots
\end{itemize}

% more or less typing work... do after hard tasks
Define $\oplus$.

Define function restriction.

Define compatibility.

Define $ch{}$.



% TODO:
% arrangement of rules?
% axioms as rules okay?
\axiomrule{nil}{}
  {\judgement{}{}{\anullproc}}

\axiomrule{msg}{}
  {\judgement{}{}{\amsnd{x}{y}}}

\infrule{act}
  {\begin{varwidth}{6cm}
    $ \rho - \{x\} = \tilde{z}, y \notin \rho,$ and \\
    $ f =
      \begin{cases}
        \ch{x, \tilde{z}} \text{ if } x \in \rho \\
        \ch{\epsilon, \tilde{z}} \text{ otherwise }
      \end{cases} $
   \end{varwidth}}
  {\judgement
    {\rho}
    {f}
    {P}}
  {\judgement
    {\{x\} \cup \tilde{z}}
    {\ch{x, \tilde{z}}}
    {\amrcv{x}{y} . P}}

\infrule{case}{$f_i$ are mutually compatible}
  {\forall\ 1 \leq i \leq n:
    \judgement{\rho_i}{f_i}{P_i}}
  {\judgement
    {(\cup_i \rho_i)}
    {(\oplus_i f_i)}
    {\acse{x}
      {\aalt{y_1}{P_1}
      ,\ldots
      ,\aalt{y_n}{P_n}}}}

\infruleII{comp}{$ \rho_1 \cap \rho_2 = \emptyset $}
  {\judgement{\rho_1}{f_1}{P_1}}
  {\judgement{\rho_2}{f_2}{P_2}}
  {\judgement{\rho_1 \cup \rho_2}{f_1 \oplus f_2}{P_1 \apar P_2}}

\infrule{res}{}
  {\judgement{\rho}{f}{P}}
  {\judgement
    {\rho - \{x\}}
    {\restrict{f}{\rho - \{x\}}}
    {\anew{x}{P}}}

\axiomrule{inst}{$\operatorname{len}(\tilde{x}) = 2$ implies $x_1 \neq x_2$}
  {\judgement
    {\{\tilde{x}\}}
    {\ch{\tilde{x}}}
    {\ains{B}{\tilde{x}}{\tilde{y}}}}

\TODO{1cm}{behavior definitions need to be type correct}

\TODO{3cm}{how are actor properties enforced?}


\subsubsection{Semantics}

Labelled transition system module alpha-equivalence.
Symmetric versions of COM, CLOSE, PAR are not shown.
Transition labels are called actions and can be of five forms:
$\tau$ (silent action),
$\actoutfree{x}{y}$ (free output of message with target $x$ and content $y$),
$\actoutbound{x}{y}$ (bound output),
$\actinfree{x}{y}$ (free input),
and $\actinbound{x}{y}$ (bound input).
We let $\alpha$ range over all visible (non-$\tau$) actions.

\axiomrule{out}{}
  {\amsnd{x}{y} \apireduction{\actoutfree{x}{y}} \anullproc}

\axiomrule{inp}{}
  {\amrcv{x}{y} . P \apireduction{\actinfree{x}{z}} P\substitution{\subst{z}{y}}}

\infrule{binp}{$ y \notin \fn{P} $}
  {P \apireduction{\actinfree{x}{y}} P'}
  {P \apireduction{\actinbound{x}{y}} P'}

\infrule{res}{$ y \notin \names{\alpha} $}
  {P \apireduction{\alpha} P'}
  {\anew{y}{P} \apireduction{\alpha} \anew{y}{P'}}

\infrule{open}{$ x \neq y $}
  {P \apireduction{\actoutfree{x}{y}} P'}
  {\anew{y}{P} \apireduction{\actoutbound{x}{y}} P'}

\infrule{par}{$ \bn{\alpha} \cap \fn{P_2} = \emptyset $}
  {P_1 \apireduction{\alpha} P_1'}
  {P_1 \apar P_2 \apireduction{\alpha} P_1' \apar P_2}

\infruleII{com}{}
  {P_1 \apireduction{\actoutfree{x}{y}} P_1'}
  {P_2 \apireduction{\actinfree{x}{y}} P_2'}
  {P_1 \apar P_2 \apireduction{\actsilent} P_1' \apar P_2}

\infruleII{close}{$ y \notin \fn{P_2} $}
  {P_1 \apireduction{\actoutbound{x}{y}} P_1'}
  {P_2 \apireduction{\actinfree{x}{y}} P_2'}
  {P_1 \apar P_2 \apireduction{\actsilent} \anew{y}{P_1' \apar P_2}}

\axiomrule{brnch}{$ x = y_i $}
  {\acse{x}{\aalt{y_1}{P_1}, \ldots, \aalt{y_n}{P_n}} \apireduction{\actsilent} P_i}

\infrule{behv}{$ \adef{B}{\tilde{x}}{\tilde{y}}{\amrcv{x_1}{z} . P} $}
  {(\amrcv{x_1}{z} . P)\substitution{\subst{(\tilde{u},\tilde{v})}{(\tilde{x},\tilde{y})}}
    \apireduction{\alpha} P'}
  {\ains{B}{\tilde{x}}{\tilde{y}} \apireduction{\alpha} P'}

\TODO{1cm}{interpret rules?}


\subsubsection{Structural Congruence}

% from Thati dissertation
% TODO: add to bibliography
\begin{align*}
  P \apar \anullproc
    &\astructequ P \\
  P \apar Q
    &\astructequ Q \apar P \\
  P \apar (Q \apar R)
    &\astructequ (P \apar Q) \apar R \\
  \\
  \anew{x}{\anullproc}
    &\astructequ \anullproc \\
  \anew{x}{\anew{y}{\anullproc}}
    &\astructequ \anew{y}{\anew{x}{\anullproc}} \\
  P \apar \anew{x}{Q}
    &\astructequ \anew*{x}{P \apar Q} \text{ if } x \notin \fn{P} \\
  \\
  \ains{B}{\tilde{u}}{\tilde{v}}
    &\astructequ \ldots \text{ if } \ldots % TODO
\end{align*}


\subsubsection{Polyadic Communication}

According to \cite{agha_algebraic_2004},
polyadic communication can be encoded in monadic \actorpicalc.

% TODO: complete
\begin{align*}
  \encPolyAP{\asnd{x}{y_1, \ldots, y_n}}
  &= \anew*{u}{\amsnd{x}{u} \apar \ains{S_1}{u}{y_1, \ldots, y_n}}
  \\
  \adef*{S_i}{u}{y_1, \ldots, y_n}
    {\amrcv{u}{z} . \parens{\amsnd{z}{y_i} \apar \ains{S_{i+1}}{u}{y_{i+1}, \ldots, y_n}}}
    && 1 \leq i \leq n
  \\
  \adef*{S_n}{}{}{...}
  \\
  \encPolyAP{\arcv{x}{y_1, \ldots, y_n}}
  &= ...
  \\
  \adef*{R_i}{}{}{...}
  \\
  \adef*{R_n}{}{}{...}
\end{align*}

\TODO{3cm}{they restrict to non-temporary names\\
  actually more general}

We adapt the \textsc{msg} and \textsc{act} rules of the type system
to accomodate polyadic communication.
In \textsc{act}, we now not only need to prevent the creation of actors
with a single name received in a message, but for all of them.
Apart from that, the rules remain unchanged.

\infrule{act}
  {\begin{varwidth}{8cm}
    $\rho - \{x\} = \tilde{z}$, $y_i \notin \rho$ for all $1 \leq i \leq n$, and \\
    $ f =
      \begin{cases}
        \ch{x, \tilde{z}} \text{ if } x \in \rho \\
        \ch{\epsilon, \tilde{z}} \text{ otherwise }
      \end{cases} $
   \end{varwidth}}
  {\judgement
    {\rho}
    {f}
    {P}}
  {\judgement
    {\{x\} \cup \tilde{z}}
    {\ch{x, \tilde{z}}}
    {\arcv{x}{y_1, \ldots, y_n} . P}}
