\section{Distributed Implementation}

We will now extend the implementation by adding the possibility to
create, refer to and migrate locations as in \distjoincalc.


\subsection{Migrating Actors}
\label{ch_migration}

Running Erlang processes cannot be migrated.
However, functions can be serialized, sent somewhere else and spawned there.
Since our provided primitives are the only places where actors are created,
we can equip them with the ability to ``wrap themselves up":
stopping their execution and returning
(a) a function capturing their behavior and
(b) their current state, which consists only of the values of their parameters.
For example, see the extended definition of the \code{forward} behavior
(figure \ref{distributed/wrap_up_forward}).
The returned data structure can then be sent to another node
and re-spawned there.

\thesislisting{distributed/wrap_up_forward}{the extended forward behavior}

This creates a new process with a new \PID,
but it should still be reachable by its name.
This requires us to generate our own globally unique names.
Fortunately, the Erlang ecosystem already provides global process registries
such as \emph{global}, which we just wrap in the \code{join_reg} module.

Another problem we have to consider is that a migrating actor,
when it handles the \code{wrap_up} message and halts execution,
might still have messages in its inbox.
Worse, even after stopping execution,
nodes that are not yet aware of the migration
could try to send a message to the old \PID.
% TODO: and we don't want to globally lock
% TODO: problems with gproc?
To prevent the loss of messages, migrating actors will immediately unregister
from their name, wait until it becomes registered somewhere else
and stay alive for a limited time to forward any remaining messages
to the new process.


\subsection{Locations}

Locations are modelled as processes with registered location names,
arranged in a tree.
They keep track of their parent location, child locations and actors.
All of these references can be \PID{}s to avoid indirections,
since actors and the parent location cannot be migrated without the location
itself.
When a child location migrates, it is not a child location anymore and can
simply be unregistered.
Similarly to actors, locations can be wrapped up,
unregistering themselves from their parent location and the registry,
and recursively wrapping up their child locations and actors.

\TODO{2cm}{physical root locations (unmovable)}


\subsection{Primitives for Distribution}

Now, we need to add an additional location parameter to many existing functions:
\begin{enumerate}[nosep]
  \item
    All actors need to be spawned at a specified location.
  \item
    While the current location is implicit in \distjoincalc,
    we choose to pass it around explicitly to simplify the implementation.
\end{enumerate}

Since we restricted ourselves to implenting \corejoincalc,
we will only add location definitions to a binary join-pattern:

\begin{align*}
  \jcoreloc{a}{x}{u}{y}{v}{P}{R}{Q}
\end{align*}

The corresponding Erlang function (figure \ref{distributed/def_location})
receives an additional location name parameter
(which is only used to generate better information for debugging).
Also the function argument now also receives the unique location name and
returns three processes.
While $Q$ is executed at the surrounding location,
$R$ will be executed at the new location $a$.

\thesislisting{distributed/def_location}{adapted location definition}

\thesislisting{distributed/def_location_usage}{using the location definition}

\TODO{3cm}{go}

% TODO: create, wrap up etc. not exposed


\subsection{Connecting Nodes}

\TODO{3cm}{need to find other nodes\\
  but no location server\\
  solution is to register names globally (but without explicit nameserver)}

\TODO{3cm}{distributed examples\\
  (explain how to start nodes and connect them)}
