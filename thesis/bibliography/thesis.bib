
@inproceedings{fournet_calculus_1996,
	address = {London, UK, UK},
	series = {{CONCUR} '96},
	title = {A {Calculus} of {Mobile} {Agents}},
	isbn = {978-3-540-61604-7},
	url = {http://dl.acm.org/citation.cfm?id=646731.703841},
	urldate = {2017-08-24},
	booktitle = {Proceedings of the 7th {International} {Conference} on {Concurrency} {Theory}},
	publisher = {Springer-Verlag},
	author = {Fournet, Cédric and Gonthier, Georges and Lévy, Jean-Jacques and Maranget, Luc and Rémy, Didier},
	year = {1996},
	pages = {406--421},
	file = {fournet.etal-mobile.pdf:/home/ubuntu/mheinzel/.mozilla/firefox/l4fqkejf.default/zotero/storage/PC6YKIU9/fournet.etal-mobile.pdf:application/pdf}
}

@inproceedings{peters_distributability_2013,
	address = {Berlin, Heidelberg},
	series = {{ESOP}'13},
	title = {On {Distributability} in {Process} {Calculi}},
	isbn = {978-3-642-37035-9},
	url = {http://dx.doi.org/10.1007/978-3-642-37036-6_18},
	doi = {10.1007/978-3-642-37036-6_18},
	abstract = {We present a novel approach to compare process calculi and their synchronisation mechanisms by using synchronisation patterns and explicitly considering the degree of distributability. For this, we propose a new quality criterion that (1) measures the preservation of distributability and (2) allows us to derive two synchronisation patterns that separate several variants of pi-like calculi. Precisely, we prove that there is no good and distributability-preserving encoding from the synchronous pi-calculus with mixed choice into its fragment with only separate choice, and neither from the asynchronous pi-calculus (without choice) into the join-calculus.},
	urldate = {2017-08-24},
	booktitle = {Proceedings of the 22Nd {European} {Conference} on {Programming} {Languages} and {Systems}},
	publisher = {Springer-Verlag},
	author = {Peters, Kirstin and Nestmann, Uwe and Goltz, Ursula},
	year = {2013},
	pages = {310--329},
	file = {peters.nestmann.distributality.pdf:/home/ubuntu/mheinzel/.mozilla/firefox/l4fqkejf.default/zotero/storage/VHHF6UAP/peters.nestmann.distributality.pdf:application/pdf}
}

@inproceedings{maranget_compiling_1998,
	title = {Compiling {Join}-{Patterns}},
	abstract = {The join-calculus is both a name passing calculus and a core language for concurrent and distributed programming. An essential part of its implementation is the compilation of join-patterns. Join-patterns define new channels and all the synchronizations they take part to at the same time. Relying on the experience based on our two implementations, we study the translation of join-patterns into deterministic finite-state automata as well as some related optimizations. 1 Introduction  Join-pattern is the distinctive feature of the join-calculus, seen both as a process calculus and as a programming language. On the calculus side, join-calculus can roughly be seen as a functional calculus plus join-patterns, thus achieving the same expressive power as previous name-passing process calculi [11]. Joindefinitions are made of several clauses, each clause being a pair of a join-pattern and of a guarded process. A join-pattern expresses a synchronization between several names (or channels). When...},
	booktitle = {Electronic {Notes} in {Computer} {Science}},
	publisher = {Elsevier Science Publishers},
	author = {Maranget, Luc and Le Fessant, Fabrice},
	year = {1998},
	file = {Citeseer - Full Text PDF:/home/ubuntu/mheinzel/.mozilla/firefox/l4fqkejf.default/zotero/storage/BF8M83YS/Maranget and Fessant - 1998 - Compiling Join-Patterns.pdf:application/pdf;Citeseer - Snapshot:/home/ubuntu/mheinzel/.mozilla/firefox/l4fqkejf.default/zotero/storage/VKRXX85J/summary.html:text/html}
}

@inproceedings{fournet_reflexive_1996,
	address = {New York, NY, USA},
	series = {{POPL} '96},
	title = {The {Reflexive} {CHAM} and the {Join}-calculus},
	isbn = {978-0-89791-769-8},
	url = {http://doi.acm.org/10.1145/237721.237805},
	doi = {10.1145/237721.237805},
	abstract = {By adding reflexion to the chemical machine of Berry and Boudol, we obtain a formal model of concurrency that is consistent with mobility and distribution. Our model provides the foundations of a programming language with functional and object-oriented features. It can also be seen as a process calculus, the join-calculus, which we prove equivalent to the ¿-calculus of Milner, Parrow and Walker.},
	urldate = {2017-08-29},
	booktitle = {Proceedings of the 23rd {ACM} {SIGPLAN}-{SIGACT} {Symposium} on {Principles} of {Programming} {Languages}},
	publisher = {ACM},
	author = {Fournet, Cédric and Gonthier, Georges},
	year = {1996},
	pages = {372--385},
	file = {ACM Full Text PDF:/home/ubuntu/mheinzel/.mozilla/firefox/l4fqkejf.default/zotero/storage/UY4GG3WE/Fournet and Gonthier - 1996 - The Reflexive CHAM and the Join-calculus.pdf:application/pdf}
}

@inproceedings{levy_results_1997,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Some results in the join-calculus},
	isbn = {978-3-540-63388-4 978-3-540-69530-1},
	url = {https://link.springer.com/chapter/10.1007/BFb0014554},
	doi = {10.1007/BFb0014554},
	abstract = {The join-calculus is a model for distributed programming languages with migratory features. It is an asynchronous process calculus based on static scope and an explicit notion of locality and failures. It allows standard polymorphic ML-like typing and thus an integration in a realistic programming language. It has a distributed implementation on top of the Caml language. We review here some of the results recently obtained in the join-calculus.},
	language = {en},
	urldate = {2017-08-30},
	booktitle = {Theoretical {Aspects} of {Computer} {Software}},
	publisher = {Springer, Berlin, Heidelberg},
	author = {Lévy, Jean-Jacques},
	month = sep,
	year = {1997},
	pages = {233--249},
	file = {levy-join.results.pdf:/home/ubuntu/mheinzel/.mozilla/firefox/l4fqkejf.default/zotero/storage/BC2G7SGW/levy-join.results.pdf:application/pdf;Snapshot:/home/ubuntu/mheinzel/.mozilla/firefox/l4fqkejf.default/zotero/storage/PZTLPJ5H/BFb0014554.html:text/html}
}

@inproceedings{fournet_jocaml:_2002,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {{JoCaml}: {A} {Language} for {Concurrent} {Distributed} and {Mobile} {Programming}},
	isbn = {978-3-540-40132-2 978-3-540-44833-4},
	shorttitle = {{JoCaml}},
	url = {https://link.springer.com/chapter/10.1007/978-3-540-44833-4_5},
	doi = {10.1007/978-3-540-44833-4_5},
	abstract = {In these lecture notes, we give an overview of concurrent, distributed, and mobile programming using JoCaml. JoCaml is an extension of the Objective Caml language. It extends OCaml with support for concurrency and synchronization, the distributed execution of programs, and the dynamic relocation of active program fragments during execution.The programming model of JoCaml is based on the join calculus. This model is characterized by an explicit notion of locality, a strict adherence to local synchronization, and a natural embedding of functional programming à la ML. Local synchronization means that messages always travel to a set destination, and can interact only after they reach that destination; this is required for an efficient asynchronous implementation. Specifically, the join calculus uses ML’s function bindings and pattern-matching on messages to express local synchronizations.The lectures and lab sessions illustrate how to use JoCaml to program concurrent and distributed applications in a much higher-level fashion than the traditional threads-and-locks approach.},
	language = {en},
	urldate = {2017-08-30},
	booktitle = {Advanced {Functional} {Programming}},
	publisher = {Springer, Berlin, Heidelberg},
	author = {Fournet, Cédric and Fessant, Fabrice Le and Maranget, Luc and Schmitt, Alan},
	month = aug,
	year = {2002},
	pages = {129--158},
	file = {fournet.lefessant-jocaml-language.pdf:/home/ubuntu/mheinzel/.mozilla/firefox/l4fqkejf.default/zotero/storage/HKFS2FN5/fournet.lefessant-jocaml-language.pdf:application/pdf;Snapshot:/home/ubuntu/mheinzel/.mozilla/firefox/l4fqkejf.default/zotero/storage/XITAJD9T/10.html:text/html}
}

@inproceedings{conchon_jocaml:_1999,
	title = {Jocaml: mobile agents for {Objective}-{Caml}},
	shorttitle = {Jocaml},
	doi = {10.1109/ASAMA.1999.805390},
	abstract = {Jocaml is a system for mobile agents built inside the Objective-Caml language. Jocaml eases the development of concurrent, distributed and mobile agent based applications, by expressing useful distribution abstractions using a small set of simple but powerful primitives taken from the Join-Calculus. The system provides total transparency for migration, application states (after migration, all threads resume their execution in the state before migration), communications (communication channels with other agents are kept during migration) and composition (sub-agents migrate with their parent agent). Other features of the Jocaml system are mobile objects with transparent remote method invocation, distributed garbage collection, failure detection and execution efficiency. Jocaml has already been used in several applications, such as a mobile editor, some distributed games and a distributed implementation of Ambients. This paper describes the Jocaml programming model and language, its current implementation and some interesting applications},
	booktitle = {Proceedings. {First} and {Third} {International} {Symposium} on {Agent} {Systems} {Applications}, and {Mobile} {Agents}},
	author = {Conchon, Sylvain and Le Fessant, Fabrice},
	year = {1999},
	keywords = {Ambients, application program interfaces, concurrent applications, distributed applications, distributed games, distributed garbage collection, distributed programming, Electrical capacitance tomography, Energy management, execution efficiency, failure detection, Internet, Java, Jocaml, Join-Calculus, mobile agent based applications, mobile agents, Mobile agents, mobile editor, mobile objects, object-oriented languages, Objective-Caml language, Power system management, Read only memory, relational algebra, remote procedure calls, Resumes, software agents, storage management, transparent remote method invocation, Virtual machining, Yarn},
	pages = {22--29},
	file = {cochon.lefessant-mobile-agents-ocaml.pdf:/home/ubuntu/mheinzel/.mozilla/firefox/l4fqkejf.default/zotero/storage/WTKYYAPW/cochon.lefessant-mobile-agents-ocaml.pdf:application/pdf;IEEE Xplore Abstract Record:/home/ubuntu/mheinzel/.mozilla/firefox/l4fqkejf.default/zotero/storage/PWVXC5DA/805390.html:text/html}
}

@book{agha_actors:_1986,
	address = {Cambridge, MA, USA},
	title = {Actors: {A} {Model} of {Concurrent} {Computation} in {Distributed} {Systems}},
	isbn = {978-0-262-01092-4},
	shorttitle = {Actors},
	publisher = {MIT Press},
	author = {Agha, Gul},
	year = {1986},
	file = {agha-actors-model-concurrent-computation.pdf:/home/ubuntu/mheinzel/.mozilla/firefox/l4fqkejf.default/zotero/storage/6ZEF5QE5/agha-actors-model-concurrent-computation.pdf:application/pdf}
}

@phdthesis{fournet_join-calculus:_1998,
	title = {The {Join}-{Calculus}: a {Calculus} for {Distributed} {Mobile} {Programming}},
	author = {Fournet, Cédric},
	year = {1998},
	file = {fournet-phd.pdf:/home/ubuntu/mheinzel/.mozilla/firefox/l4fqkejf.default/zotero/storage/PJ7N66RI/fournet-phd.pdf:application/pdf}
}

@incollection{agha_algebraic_2004,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {An {Algebraic} {Theory} of {Actors} and {Its} {Application} to a {Simple} {Object}-{Based} {Language}},
	isbn = {978-3-540-21366-6 978-3-540-39993-3},
	url = {https://link.springer.com/chapter/10.1007/978-3-540-39993-3_4},
	abstract = {The development of Simula by Ole-Johan Dahl and Kristen Nygaard introduced a number of important programming language concepts – object which supports modularity in programming through encapsulation of data and procedures, the concept of class which organizes behavior and supports Abstract Data Types, and the concept inheritance which provides subtyping relations and reuse [6]. Peter Wegner terms programming languages which use objects as object-based languages, and reserves the term object-oriented languages for languages which also support classes and inheritance [58].},
	language = {en},
	urldate = {2017-11-09},
	booktitle = {From {Object}-{Orientation} to {Formal} {Methods}},
	publisher = {Springer, Berlin, Heidelberg},
	author = {Agha, Gul and Thati, Prasanna},
	year = {2004},
	note = {DOI: 10.1007/978-3-540-39993-3\_4},
	pages = {26--57},
	file = {Full Text PDF:/home/ubuntu/mheinzel/.mozilla/firefox/l4fqkejf.default/zotero/storage/LXKA4T2X/Agha and Thati - 2004 - An Algebraic Theory of Actors and Its Application .pdf:application/pdf;Snapshot:/home/ubuntu/mheinzel/.mozilla/firefox/l4fqkejf.default/zotero/storage/Y43G8E5C/978-3-540-39993-3_4.html:text/html}
}

@techreport{boudol_asynchrony_1992,
	title = {Asynchrony and the {Pi}-{Calculus}},
	abstract = {We introduce an asynchronous version of Milner's ß-calculus, based on the idea that the messages are elementary processes that can be sent without any sequencing constraint. We show that this simple message passing discipline, together with the restriction construct making a name private for an agent, is enough to encode the synchronous communication of the ß-calculus.  1. Introduction.  The purpose of this note is to introduce an asynchronous variant of the ß-calculus of Milner, Parrow and Walker [8]. The ß-calculus is an extension of CCS, based on previous work by Engberg and Nielsen [5], that deals with name passing: in this calculus, agents pass channel names to other agents through named channels. The expressiveness of this link passing discipline has been demonstrated in [8] by a series of examples. Later on, Milner showed in [9] that even a restricted fragment of the original ß-calculus is enough to encode the -calculus. More precisely, he showed that one can mimic in a "mini" ß...},
	author = {Boudol, Gérard},
	year = {1992},
	file = {Citeseer - Full Text PDF:/home/ubuntu/mheinzel/.mozilla/firefox/l4fqkejf.default/zotero/storage/ENBA8BWQ/Boudol - 1992 - Asynchrony and the Pi-Calculus.pdf:application/pdf;Citeseer - Snapshot:/home/ubuntu/mheinzel/.mozilla/firefox/l4fqkejf.default/zotero/storage/IH6TZ4DJ/summary.html:text/html}
}

@inproceedings{honda_object_1991,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {An object calculus for asynchronous communication},
	isbn = {978-3-540-54262-9 978-3-540-47537-8},
	url = {https://link.springer.com/chapter/10.1007/BFb0057019},
	doi = {10.1007/BFb0057019},
	abstract = {This paper presents a formal system based on the notion of objects and asynchronous communication. Built on Milner's work on π-calculus, the communication primitive of the formal system is purely based on asynchronous communication, which makes it unique among various concurrency formalisms. Computationally this results in a consistent reduction of Milner's calculus, while retaining the same expressive power. Seen semantically asynchronous communication induces a surprisingly different framework where bisimulation is strictly more general than its synchronous counterpart. This paper shows basic construction of the formal system along with several illustrative examples.},
	language = {en},
	urldate = {2018-02-18},
	booktitle = {{ECOOP}'91 {European} {Conference} on {Object}-{Oriented} {Programming}},
	publisher = {Springer, Berlin, Heidelberg},
	author = {Honda, Kohei and Tokoro, Mario},
	month = jul,
	year = {1991},
	pages = {133--147},
	file = {Snapshot:/home/ubuntu/mheinzel/.mozilla/firefox/l4fqkejf.default/zotero/storage/REIULK9Y/BFb0057019.html:text/html}
}

@inproceedings{berry_chemical_1990,
	address = {New York, NY, USA},
	series = {{POPL} '90},
	title = {The {Chemical} {Abstract} {Machine}},
	isbn = {978-0-89791-343-0},
	url = {http://doi.acm.org/10.1145/96709.96717},
	doi = {10.1145/96709.96717},
	abstract = {We introduce a new kind of abstract machine based on the chemical metaphor used in the \&Ggr; language of Banâtre \& al. States of a machine are chemical solutions where floating molecules can interact according to reaction rules. Solutions can be stratified by encapsulating subsolutions within membranes that force reactions to occur locally. We illustrate the use of this model by describing the operational semantics of the TCCS and CCS process calculi. We also show how to extract a higher-order concurrent \&lgr;-calculus out of the basic concepts of the chemical abstract machine.},
	urldate = {2018-02-18},
	booktitle = {Proceedings of the 17th {ACM} {SIGPLAN}-{SIGACT} {Symposium} on {Principles} of {Programming} {Languages}},
	publisher = {ACM},
	author = {Berry, Gerard and Boudol, Gerard},
	year = {1990},
	pages = {81--94}
}

@inproceedings{hewitt_universal_1973,
	address = {San Francisco, CA, USA},
	series = {{IJCAI}'73},
	title = {A {Universal} {Modular} {ACTOR} {Formalism} for {Artificial} {Intelligence}},
	url = {http://dl.acm.org/citation.cfm?id=1624775.1624804},
	abstract = {This paper proposes a modular ACTOR architecture and definitional method for artificial intelligence that is conceptually based on a single kind of object: actors [or, if you will, virtual processors, activation frames, or streams]. The formalism makes no presuppositions about the representation of primitive data structures and control structures. Such structures can be programmed, micro-coded, or hard wired in a uniform modular fashion. In fact it is impossible to determine whether a given object is "really" represented as a list, a vector, a hash table, a function, or a process. The architecture will efficiently run the coming generation of PLANNER-like artificial intelligence languages including those requiring a high degree of parallelism. The efficiency is gained without loss of programming generality because it only makes certain actors more efficient; it does not change their behavioral characteristics. The architecture is general with respect to control structure and does not have or need goto, interrupt, or semaphore primitives. The formalism achieves the goals that the disallowed constructs are intended to achieve by other more structured methods.},
	urldate = {2018-03-02},
	booktitle = {Proceedings of the 3rd {International} {Joint} {Conference} on {Artificial} {Intelligence}},
	publisher = {Morgan Kaufmann Publishers Inc.},
	author = {Hewitt, Carl and Bishop, Peter and Steiger, Richard},
	year = {1973},
	pages = {235--245}
}
