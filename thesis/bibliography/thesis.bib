
@article{benton_modern_2002,
	title = {Modern {Concurrency} {Abstractions} for {C}\#},
	volume = {2374},
	url = {https://www.microsoft.com/en-us/research/publication/modern-concurrency-abstractions-for-c/},
	abstract = {Polyphonic C\# is an extension of the C\# language with new asynchronous concurrency constructs, based on the join calculus. We describe the design and implementation of the language and give examples of its use in addressing a range of concurrent programming problems.},
	journal = {ACM Transactions on Programming Languages and Systems (TOPLAS)},
	author = {Benton, Nick and Cardelli, Luca and Fournet, Cédric},
	month = jun,
	year = {2002},
	file = {C-Sharp-concurrency.pdf:/home/ubuntu/mheinzel/.mozilla/firefox/l4fqkejf.default/zotero/storage/9PIMN7V7/C-Sharp-concurrency.pdf:application/pdf;Snapshot:/home/ubuntu/mheinzel/.mozilla/firefox/l4fqkejf.default/zotero/storage/4TRRBCU2/modern-concurrency-abstractions-for-c.html:text/html}
}

@inproceedings{itzstein_implementing_2003,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {On {Implementing} {High} {Level} {Concurrency} in {Java}},
	isbn = {978-3-540-20122-9 978-3-540-39864-6},
	url = {https://link.springer.com/chapter/10.1007/978-3-540-39864-6_13},
	doi = {10.1007/978-3-540-39864-6_13},
	abstract = {Increasingly threading has become an important architectural component of programming languages to support parallel programming. Previously we have proposed an elegant language extension to express concurrency and synchronization. This language called Join Java has all the expressiveness of Object Oriented languages whilst offering the added benefit of superior synchronization and concurrency semantics. Join Java incorporates asynchronous method calls and message passing. Synchronisation is expressed by a conjunction of method calls that execute associated code only when all parts of the condition are satisfied. A prototype of the Join Java language extension has been implemented using a fully functional Java compiler allowing us to illustrate how the extension preserves Join semantics within the Java language. This paper reviews the issues surrounding the addition of Join calculus constructs to an Object Oriented language and our implementation with Java. We describe how, whilst the Join calculus is non-deterministic, a form of determinism can and should be specified in Join Java. We explain the need for a sophisticated yet fast pattern matcher to be present to support the Join Java compiler. We also give reasons why inheritance of Join patterns is restricted in our initial implementation.},
	language = {en},
	urldate = {2017-08-30},
	booktitle = {Advances in {Computer} {Systems} {Architecture}},
	publisher = {Springer, Berlin, Heidelberg},
	author = {Itzstein, G Stewart and Jasiunas, Mark},
	month = sep,
	year = {2003},
	pages = {151--165},
	file = {itzstein.jaiunas-implementing-join-java.pdf:/home/ubuntu/mheinzel/.mozilla/firefox/l4fqkejf.default/zotero/storage/8H9TZPWK/itzstein.jaiunas-implementing-join-java.pdf:application/pdf;Snapshot:/home/ubuntu/mheinzel/.mozilla/firefox/l4fqkejf.default/zotero/storage/X69CKFJF/978-3-540-39864-6_13.html:text/html}
}

@article{haller_implementing_2008,
	title = {Implementing {Joins} using {Extensible} {Pattern} {Matching}},
	url = {https://infoscience.epfl.ch/record/125992},
	journal = {Proceedings of the 10th International Conference on Coordination Models and Languages},
	author = {Haller, Philipp and Van Cutsem, Tom},
	year = {2008},
	pages = {135--152},
	file = {Full Text PDF:/home/ubuntu/mheinzel/.mozilla/firefox/l4fqkejf.default/zotero/storage/UPR8ZE5Z/Haller and Van Cutsem - 2008 - Implementing Joins using Extensible Pattern Matchi.pdf:application/pdf;Snapshot:/home/ubuntu/mheinzel/.mozilla/firefox/l4fqkejf.default/zotero/storage/644YZMFI/125992.html:text/html}
}

@inproceedings{conchon_jocaml_1999,
	title = {Jocaml: mobile agents for {Objective}-{Caml}},
	shorttitle = {Jocaml},
	doi = {10.1109/ASAMA.1999.805390},
	abstract = {Jocaml is a system for mobile agents built inside the Objective-Caml language. Jocaml eases the development of concurrent, distributed and mobile agent based applications, by expressing useful distribution abstractions using a small set of simple but powerful primitives taken from the Join-Calculus. The system provides total transparency for migration, application states (after migration, all threads resume their execution in the state before migration), communications (communication channels with other agents are kept during migration) and composition (sub-agents migrate with their parent agent). Other features of the Jocaml system are mobile objects with transparent remote method invocation, distributed garbage collection, failure detection and execution efficiency. Jocaml has already been used in several applications, such as a mobile editor, some distributed games and a distributed implementation of Ambients. This paper describes the Jocaml programming model and language, its current implementation and some interesting applications},
	booktitle = {Proceedings. {First} and {Third} {International} {Symposium} on {Agent} {Systems} {Applications}, and {Mobile} {Agents}},
	author = {Conchon, Sylvain and Le Fessant, Fabrice},
	year = {1999},
	keywords = {Ambients, application program interfaces, concurrent applications, distributed applications, distributed games, distributed garbage collection, distributed programming, Electrical capacitance tomography, Energy management, execution efficiency, failure detection, Internet, Java, Jocaml, Join-Calculus, mobile agent based applications, mobile agents, Mobile agents, mobile editor, mobile objects, object-oriented languages, Objective-Caml language, Power system management, Read only memory, relational algebra, remote procedure calls, Resumes, software agents, storage management, transparent remote method invocation, Virtual machining, Yarn},
	pages = {22--29},
	file = {cochon.lefessant-mobile-agents-ocaml.pdf:/home/ubuntu/mheinzel/.mozilla/firefox/l4fqkejf.default/zotero/storage/WTKYYAPW/cochon.lefessant-mobile-agents-ocaml.pdf:application/pdf;IEEE Xplore Abstract Record:/home/ubuntu/mheinzel/.mozilla/firefox/l4fqkejf.default/zotero/storage/PWVXC5DA/805390.html:text/html}
}

@inproceedings{fournet_implicit_1997,
	title = {Implicit typing à la {ML} for the join-calculus},
	abstract = {We adapt the Damas-Milner typing discipline to the join-calculus. The main result is a new generalization criterion that extends the polymorphism of ML to join-definitions. We prove the correctness of our typing rules with regard to a chemical semantics. We also relate typed extensions of the core join-calculus to functional languages.},
	booktitle = {Proceedings of the 8th {International} {Conference} on {Concurrency} {Theory}, volume 1243 of {Lecture} {Notes} in {Computer} {Science}},
	publisher = {Springer-Verlag},
	author = {Fournet, Cédric and Laneve, Cosimo and Maranget, Luc and Rémy, Didier},
	year = {1997},
	pages = {196--212},
	file = {Citeseer - Full Text PDF:/home/ubuntu/mheinzel/.mozilla/firefox/l4fqkejf.default/zotero/storage/I7Q2UPLR/Fournet et al. - 1997 - Implicit typing à la ML for the join-calculus.pdf:application/pdf;Citeseer - Snapshot:/home/ubuntu/mheinzel/.mozilla/firefox/l4fqkejf.default/zotero/storage/9ZWSWEG8/summary.html:text/html}
}

@inproceedings{levy_results_1997,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Some results in the join-calculus},
	isbn = {978-3-540-63388-4 978-3-540-69530-1},
	url = {https://link.springer.com/chapter/10.1007/BFb0014554},
	doi = {10.1007/BFb0014554},
	abstract = {The join-calculus is a model for distributed programming languages with migratory features. It is an asynchronous process calculus based on static scope and an explicit notion of locality and failures. It allows standard polymorphic ML-like typing and thus an integration in a realistic programming language. It has a distributed implementation on top of the Caml language. We review here some of the results recently obtained in the join-calculus.},
	language = {en},
	urldate = {2017-08-30},
	booktitle = {Theoretical {Aspects} of {Computer} {Software}},
	publisher = {Springer, Berlin, Heidelberg},
	author = {Lévy, Jean-Jacques},
	month = sep,
	year = {1997},
	pages = {233--249},
	file = {levy-join.results.pdf:/home/ubuntu/mheinzel/.mozilla/firefox/l4fqkejf.default/zotero/storage/BC2G7SGW/levy-join.results.pdf:application/pdf;Snapshot:/home/ubuntu/mheinzel/.mozilla/firefox/l4fqkejf.default/zotero/storage/PZTLPJ5H/BFb0014554.html:text/html}
}

@inproceedings{fournet_calculus_1996,
	address = {London, UK, UK},
	series = {{CONCUR} '96},
	title = {A {Calculus} of {Mobile} {Agents}},
	isbn = {978-3-540-61604-7},
	url = {http://dl.acm.org/citation.cfm?id=646731.703841},
	urldate = {2017-08-24},
	booktitle = {Proceedings of the 7th {International} {Conference} on {Concurrency} {Theory}},
	publisher = {Springer-Verlag},
	author = {Fournet, Cédric and Gonthier, Georges and Lévy, Jean-Jacques and Maranget, Luc and Rémy, Didier},
	year = {1996},
	pages = {406--421},
	file = {fournet.etal-mobile.pdf:/home/ubuntu/mheinzel/.mozilla/firefox/l4fqkejf.default/zotero/storage/PC6YKIU9/fournet.etal-mobile.pdf:application/pdf}
}

@inproceedings{peters_distributability_2013,
	address = {Berlin, Heidelberg},
	series = {{ESOP}'13},
	title = {On {Distributability} in {Process} {Calculi}},
	isbn = {978-3-642-37035-9},
	url = {http://dx.doi.org/10.1007/978-3-642-37036-6_18},
	doi = {10.1007/978-3-642-37036-6_18},
	abstract = {We present a novel approach to compare process calculi and their synchronisation mechanisms by using synchronisation patterns and explicitly considering the degree of distributability. For this, we propose a new quality criterion that (1) measures the preservation of distributability and (2) allows us to derive two synchronisation patterns that separate several variants of pi-like calculi. Precisely, we prove that there is no good and distributability-preserving encoding from the synchronous pi-calculus with mixed choice into its fragment with only separate choice, and neither from the asynchronous pi-calculus (without choice) into the join-calculus.},
	urldate = {2017-08-24},
	booktitle = {Proceedings of the 22Nd {European} {Conference} on {Programming} {Languages} and {Systems}},
	publisher = {Springer-Verlag},
	author = {Peters, Kirstin and Nestmann, Uwe and Goltz, Ursula},
	year = {2013},
	pages = {310--329},
	file = {peters.nestmann.distributality.pdf:/home/ubuntu/mheinzel/.mozilla/firefox/l4fqkejf.default/zotero/storage/VHHF6UAP/peters.nestmann.distributality.pdf:application/pdf}
}

@inproceedings{maranget_compiling_1998,
	title = {Compiling {Join}-{Patterns}},
	abstract = {The join-calculus is both a name passing calculus and a core language for concurrent and distributed programming. An essential part of its implementation is the compilation of join-patterns. Join-patterns define new channels and all the synchronizations they take part to at the same time. Relying on the experience based on our two implementations, we study the translation of join-patterns into deterministic finite-state automata as well as some related optimizations. 1 Introduction  Join-pattern is the distinctive feature of the join-calculus, seen both as a process calculus and as a programming language. On the calculus side, join-calculus can roughly be seen as a functional calculus plus join-patterns, thus achieving the same expressive power as previous name-passing process calculi [11]. Joindefinitions are made of several clauses, each clause being a pair of a join-pattern and of a guarded process. A join-pattern expresses a synchronization between several names (or channels). When...},
	booktitle = {Electronic {Notes} in {Computer} {Science}},
	publisher = {Elsevier Science Publishers},
	author = {Maranget, Luc and Le Fessant, Fabrice},
	year = {1998},
	file = {Citeseer - Full Text PDF:/home/ubuntu/mheinzel/.mozilla/firefox/l4fqkejf.default/zotero/storage/BF8M83YS/Maranget and Fessant - 1998 - Compiling Join-Patterns.pdf:application/pdf;Citeseer - Snapshot:/home/ubuntu/mheinzel/.mozilla/firefox/l4fqkejf.default/zotero/storage/VKRXX85J/summary.html:text/html}
}

@article{mandel_programming_2007,
	title = {Programming in {JoCaml} --- {Extended} {Version}},
	url = {https://core.ac.uk/display/50367597},
	abstract = {JoCaml is a language for concurrent and distributed programming. We here present a non-trival distributed application written in JoCaml: a ray{\textasciitilde}tracer. Thereby, we show how to program the coordination of multiple cooperating agents in a concise manner, in the spirit of functional programming. We also adress the issue of agent failure},
	urldate = {2017-08-29},
	author = {Mandel, Louis and Maranget, Luc},
	year = {2007},
	note = {Available at \url{http://pauillac.inria.fr/~maranget/papers/jocamlrus/jocamlrus.pdf}},
	file = {MandelMaranget-RR-2007.pdf:/home/ubuntu/mheinzel/.mozilla/firefox/l4fqkejf.default/zotero/storage/Q29M5I2V/MandelMaranget-RR-2007.pdf:application/pdf;Snapshot:/home/ubuntu/mheinzel/.mozilla/firefox/l4fqkejf.default/zotero/storage/BJ3ZAR2K/50367597.html:text/html}
}

@inproceedings{russo_joins_2007,
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {The {Joins} {Concurrency} {Library}},
	isbn = {978-3-540-69608-7 978-3-540-69611-7},
	url = {https://link.springer.com/chapter/10.1007/978-3-540-69611-7_17},
	doi = {10.1007/978-3-540-69611-7_17},
	abstract = {Cω extended C\# 1.x with a simple, declarative and powerful model of concurrency – join patterns – applicable both to multithreaded applications and to the orchestration of asynchronous, event-based distributed applications. With Generics available in C\# 2.0, we can now provide join patterns as a library rather than a language feature. The Joins library extends its clients with an embedded, type-safe and mostly declarative language for expressing synchronization patterns. The library has some advantages over Cω: it is language neutral, supporting other languages like Visual Basic; its join patterns are more dynamic, allowing solutions difficult to express with Cω; its code is easy to modify, fostering experimentation. Although presenting fewer optimization opportunities, the implementation is efficient and its interface makes it trivial to translate Cω programs to C\#. We describe the interface and implementation of Joins which (ab)uses almost every feature of Generics.},
	language = {en},
	urldate = {2017-08-29},
	booktitle = {Practical {Aspects} of {Declarative} {Languages}},
	publisher = {Springer, Berlin, Heidelberg},
	author = {Russo, Claudio},
	month = jan,
	year = {2007},
	pages = {260--274},
	file = {Full Text PDF:/home/ubuntu/mheinzel/.mozilla/firefox/l4fqkejf.default/zotero/storage/LK6DFCXU/Russo - 2007 - The Joins Concurrency Library.pdf:application/pdf;Snapshot:/home/ubuntu/mheinzel/.mozilla/firefox/l4fqkejf.default/zotero/storage/MQ7R4DFQ/978-3-540-69611-7_17.html:text/html}
}

@inproceedings{fournet_reflexive_1996,
	address = {New York, NY, USA},
	series = {{POPL} '96},
	title = {The {Reflexive} {CHAM} and the {Join}-calculus},
	isbn = {978-0-89791-769-8},
	url = {http://doi.acm.org/10.1145/237721.237805},
	doi = {10.1145/237721.237805},
	abstract = {By adding reflexion to the chemical machine of Berry and Boudol, we obtain a formal model of concurrency that is consistent with mobility and distribution. Our model provides the foundations of a programming language with functional and object-oriented features. It can also be seen as a process calculus, the join-calculus, which we prove equivalent to the ¿-calculus of Milner, Parrow and Walker.},
	urldate = {2017-08-29},
	booktitle = {Proceedings of the 23rd {ACM} {SIGPLAN}-{SIGACT} {Symposium} on {Principles} of {Programming} {Languages}},
	publisher = {ACM},
	author = {Fournet, Cédric and Gonthier, Georges},
	year = {1996},
	pages = {372--385},
	file = {ACM Full Text PDF:/home/ubuntu/mheinzel/.mozilla/firefox/l4fqkejf.default/zotero/storage/UY4GG3WE/Fournet and Gonthier - 1996 - The Reflexive CHAM and the Join-calculus.pdf:application/pdf}
}

@article{hewitt_viewing_1977,
	title = {Viewing control structures as patterns of passing messages},
	volume = {8},
	issn = {0004-3702},
	url = {http://www.sciencedirect.com/science/article/pii/0004370277900339},
	doi = {10.1016/0004-3702(77)90033-9},
	abstract = {The purpose of this paper is to discuss some organizational aspects of programs using the actor model of computation. In this paper we present an approach to modelling intelligence in terms of a society of communicating knowledge-based problem-solving experts. In turn each of the experts can be viewed as a society that can be further decomposed in the same way until the primitive actors of the system are reached. We are investigating the nature of the communication mechanisms needed for effective problem-solving by a society of experts and the conventions of civilized discourse that make this possible. In this way we hope eventually to develop a framework adequate for the discussion of the central issues of problem-solving involving parallel versus serial processing and centralization versus decentralization of control and information storage. This paper demonstrates how actor message passing can be used to understand control structures as patterns of passing messages in serial processing. This paper is a pre-requisite for successors which treat issues of parallelism and communication within the framework established here. The ability to analyze or synthesize any kind of control structure as a pattern of passing messages among the members of a society provides an important tool for understanding control structures. Ultimately, we hope to be able to characterize various control structures in common use by societies in terms of patterns of passing messages. This paper makes a small step in this direction by showing how to characterize familiar control structures such as iteration and recursion in these terms.},
	number = {3},
	urldate = {2017-09-11},
	journal = {Artificial Intelligence},
	author = {Hewitt, Carl},
	month = jun,
	year = {1977},
	pages = {323--364},
	file = {hewitt-viewing-control-structures.pdf:/home/ubuntu/mheinzel/.mozilla/firefox/l4fqkejf.default/zotero/storage/9RF9LKZL/hewitt-viewing-control-structures.pdf:application/pdf;ScienceDirect Snapshot:/home/ubuntu/mheinzel/.mozilla/firefox/l4fqkejf.default/zotero/storage/LJP8EGIM/0004370277900339.html:text/html}
}

@book{agha_actors_1986,
	address = {Cambridge, MA, USA},
	title = {Actors: {A} {Model} of {Concurrent} {Computation} in {Distributed} {Systems}},
	isbn = {978-0-262-01092-4},
	shorttitle = {Actors},
	publisher = {MIT Press},
	author = {Agha, Gul},
	year = {1986},
	file = {agha-actors-model-concurrent-computation.pdf:/home/ubuntu/mheinzel/.mozilla/firefox/l4fqkejf.default/zotero/storage/6ZEF5QE5/agha-actors-model-concurrent-computation.pdf:application/pdf}
}
