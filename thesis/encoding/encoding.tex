\section{\CoreJoinCalc to \ActorPiCalc}

\subsection{A Naive Approach}

The simple translation of \joincalc into \asyncpicalc
\cite{fournet_reflexive_1996}
cannot be re-used for the translation to \actorpicalc,
since it does not adhere to its typing rules.

\begin{align*}
  \encMJtoAP{P \jpar Q}
  &= \encMJtoAP{P} \apar \encMJtoAP{Q}
  \\
  \encMJtoAP{\jsnd{x}{y}}
  &= \asnd{x}{y}
  \\
  \encMJtoAP{\jdef{\jrct{\jrcv{x}{u} \jpat \jrcv{y}{v}}{P}}{Q}}
  &= \anew{x}{\anew{y}{\parens{\ains{B}{x, y}{} \apar Q}}}
  \\
  \text{with }
  \adef*{B}{x,y}{}{\arcv{x}{u} . \arcv{y}{v} . \parens{\ains{B}{x, y}{} \apar \ains{P}{}{}}} \\
\end{align*}

\TODO{3cm}{typing derivation?}

\TODO{2cm}{reason: actor cannot receive on two channels interchangeably}


\subsection{Forwarding}

\TODO{3cm}{idea: sending both $x$ and $y$ to same actor}

\begin{align*}
  \adef*{B_{fw}}{x}{a}{\arcv{x}{i} . \parens{\asnd{a}{x,i} \apar \ains{B_{fw}}{x}{a}}}
\end{align*}

\subsection{Storing Payloads}

\TODO{3cm}{problem: can receive $x$ and $y$ in arbitrary order\\
  receive two $x$s, need to respawn\\
  introduces divergence\\
  we need some storage}

We can use church-encoding to build lists from actors and avoid divergence.

\TODO{2cm}{explain church-encoding}

\begin{align*}
  \adef*{B_{nil}}{l}{}{\arcv{l}{k_n,k_c} . \asnd{k_n}{}}
  \\
  \adef*{B_{cons}}{l}{h,t}{\arcv{l}{k_n,k_c} . \asnd{k_c}{h,t}}
\end{align*}

The actor now receives forwarded messages from both channels $x$ and $y$.
If it receives more messages from one of these channels than from the other,
it stores the excess payloads in a list and remembers from which channel
these came (as there can only be excessive messages on one of these channels).

\begin{align*}
  \adef*{B_a^P}{a}{x,y,f,l}{\arcv{a}{c,p} . \anew{k_n}{\anew{k_c}{
  \\ & \hspace{1cm}
    \big(\ \asnd{l}{k_n,k_c}
  \\ & \hspace{1cm}
    \apar \arcv{k_n}{} . \anew{l'}{\parens{\ains{B_{cons}}{l'}{p, l} \apar \ains{B_a^P}{a}{x, y, c, l'}}}
  \\ & \hspace{1cm}
    \apar \arcv{k_c}{h,t} . \acse{c}{\right.
  \\ & \hspace{3cm}
    \aalt{f}{\anew{l'}{\parens{\ains{B_{cons}}{l'}{p, l} \apar \ains{B_a^P}{a}{x, y, f, l'}}}},
  \\ & \hspace{3cm}
    \aalt{x}{\anew{l'}{\parens{\ains{B_{join}^P}{l'}{p, h, t} \apar \ains{B_a^P}{a}{x, y, f, l'}}}}
  \\ & \hspace{3cm}
    \aalt{y}{\anew{l'}{\parens{\ains{B_{join}^P}{l'}{p, h, t} \apar \ains{B_a^P}{a}{x, y, f, l'}}}}
    \left.}\big)
  }}} \\
\end{align*}

To encode a \joincalc definition,
we now start one such joining actor (with initially no excess payloads),
a forwarder for each channel
and the encoded subprocess in which the definition is available.

% TODO: continuation to make type correct
% TODO: free variables of P in parameters
\begin{align*}
  \encMJtoAP{\jdef{\jrct{\jrcv{x}{u} \jpat \jrcv{y}{v}}{P}}{Q}}
  = \anew{a}{\anew{x}{\anew{y}{\anew{l}{
    &\big(\ \ains{B_a^P}{a}{x, y, x, l} \\
    &\apar \ains{B_{fw}}{x}{a} \apar \ains{B_{fw}}{y}{a} \\
    &\apar \ains{B_{nil}}{l}{} \\
    &\apar \encMJtoAP{Q}
  \ \big)}}}} \\
\end{align*}

\TODO{4cm}{type correctness\\
  $\judgement{}{}{\encMJtoAP{P}}$ for all core join terms $P$ (by structural induction)\\
  then check type correctness of definitions}

\TODO{4cm}{"operational correspondence"}


\subsection{Full Abstraction}

\TODO{3cm}{join-pi encodings require firewall for full abstraction\\
  (explain why by example?)\\
  this is not necessary here, because ...}
