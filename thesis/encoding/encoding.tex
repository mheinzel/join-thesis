\section{\CoreJoinCalc to \ActorPiCalc}

\subsection{A Naive Approach}

The simple translation of \joincalc into \asyncpicalc \cite{fournet_reflexive_1996} cannot be re-used for the translation to \actorpicalc,
since it does not adhere to its typing rules.

\begin{align*}
  \encMJtoAP{P \jpar Q}
  &= \encMJtoAP{P} \apar \encMJtoAP{Q}
  \\
  \encMJtoAP{\jsnd{x}{y}}
  &= \asnd{x}{y}
  \\
  \encMJtoAP{\jdef{\jrct{\jrcv{x}{u} \jpat \jrcv{y}{v}}{P}}{Q}}
  &= \anew{x}{\anew{y}{\parens{\ains{B}{x, y}{} \apar Q}}}
  \\
  \text{with }
  \adef*{B}{x,y}{}{\arcv{x}{u} . \arcv{y}{v} . \parens{\ains{B}{x, y}{} \apar \ains{P}{}{}}} \\
\end{align*}

\TODO{5cm}{typing derivation\\
  explain problem}


\subsection{A More Complex Approach}

Using polyadic communication:

A more complex approach is to store available $x$ and $y$ payloads in a (church-encoded) list, avoiding divergence.

\begin{align}
  \encMJtoAP{\jdef{\jrct{\jrcv{x}{u} \jpat \jrcv{y}{v}}{P}}{Q}}
  =\
  \anew{a}{\anew{x}{\anew{y}{\anew{l_x}{\anew{l_y}{
    &\big(\ \ains{B_a^P}{a}{x, y, l_x, l_y} \nonumber \\
    &\apar \ains{B_c}{x}{a} \apar \ains{B_c}{y}{a} \nonumber \\
    &\apar \ains{B_{nil}}{l_x}{} \apar \ains{B_{nil}}{l_y}{} \nonumber \\
    &\apar \encMJtoAP{Q}\ \big)
  }}}}}
\end{align}

% TODO: polyadic receive on temporary name not covered by Thati!
\begin{align}
  \adef*{B_c}{x}{a}{\arcv{x}{i} . \parens{\asnd{a}{x,i} \apar \ains{B_c}{x}{a}}}
  \\
  \adef*{B_{nil}}{l}{}{\arcv{l}{k_n,k_c} . \asnd{k_n}{}}
  \\
  \adef*{B_{cons}}{l}{h,t}{\arcv{l}{k_n,k_c} . \asnd{k_c}{h,t}}
  \\
  \adef*{B_a^P}{a}{x,y,l_u,l_v}{
    \arcv{a}{c,i} . \anew{k}{\anew{t}{
      \acse{c}{ \right. \nonumber \\
        & \hspace{1cm}
          \aalt{x}{\ains{B_{insert}^P}{t}{i, l_u, l_v} \apar \asnd{t}{k} \apar \arcv{k}{l_{u,new},l_{v,new}} . \ains{B_a^P}{a}{x, y, l_{u,new}, l_{v,new}}}, \nonumber \\
        & \hspace{1cm}
          \aalt{y}{\ains{B_{insert}^P}{t}{i, l_v, l_u} \apar \asnd{t}{k} \apar \arcv{k}{l_{v,new},l_{u,new}} . \ains{B_a^P}{a}{x, y, l_{u,new}, l_{v,new}}}
    \left.}}}
  } \\
  \adef*{B_{insert}^P}{t}{u,l_u,l_v}{
    \arcv{t}{k} . \anew{k_c}{\anew{k_n}{ \nonumber \\
      & \hspace{1cm}
        \big(\ \asnd{l_v}{k_n,k_c} \nonumber \\
      & \hspace{1cm}
        \apar \arcv{k_n}{} . \anew{l_{u,new}}{\parens{\ains{B_{cons}}{l_{u,new}}{u, l_u} \apar \asnd{k}{l_{u,new},l_v}}} \nonumber \\
      & \hspace{1cm}
        \apar \arcv{k_c}{h_v,t_v} . \anew{l_{v,new}}{\parens{\ains{B_{join}^P}{l_{v,new}}{u, h_v, t_v} \apar \asnd{k}{l_u,l_{v,new}}}} \big)
    }}
  } \\
  \adef*{B_{join}^P}{l}{u,v,l_v}{
    \arcv{l}{r_n,r_c} . \anew{k_n}{\anew{k_c}{ \nonumber \\
      & \hspace{1cm}
        \big(\ \asnd{l_v}{k_n,k_c} \nonumber \\
      & \hspace{1cm}
        \apar \arcv{k_n}{} . \parens{\encMJtoAP{P} \apar \asnd{r_n}{}} \nonumber \\
      & \hspace{1cm}
        \apar \arcv{k_c}{h_v,t_v} . \acse{u}{ \right. \nonumber \\
          & \hspace{2cm}
            \aalt{u}{\encMJtoAP{P} \apar \asnd{r_c}{h_v,t_v}}, \nonumber \\
          & \hspace{2cm}
            \aalt{u}{\anew{l_{joined}}{\parens{\ains{B_{join}^P}{l_{joined}}{u, h_v, t_v} \apar \asnd{r_c}{v,l_{joined}}}}}
        \left.}\big)
    }}
  }
\end{align}

% show type correctness


\subsection{Full Abstraction}

% "join <-> pi" encodings require firewall for full abstraction
% (explain why by example?)
% this is not necessary here
% because ...
