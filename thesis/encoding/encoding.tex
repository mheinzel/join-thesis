\section{\CoreJoinCalc to \ActorPiCalc}

\subsection{A Naive Approach}

The simple translation of \joincalc into \asyncpicalc
\cite{fournet_reflexive_1996}
cannot be re-used for the translation to \actorpicalc,
since it does not adhere to its typing rules.

\begin{align*}
  \encMJtoAP{P \jpar Q}
  &= \encMJtoAP{P} \apar \encMJtoAP{Q}
  \\
  \encMJtoAP{\jsnd{x}{y}}
  &= \asnd{x}{y}
  \\
  \encMJtoAP{\jdef{\jrct{\jrcv{x}{u} \jpat \jrcv{y}{v}}{P}}{Q}}
  &= \anew{x}{\anew{y}{\parens{\ains{B}{x, y}{\tilde{z}} \apar \encMJtoAP{Q}}}}
  \\
  \text{with }
  \adef*{B}{x,y}{\tilde{z}}{\arcv{x}{u} . \arcv{y}{v} . \parens{\ains{B}{x, y}{\tilde{z}} \apar \encMJtoAP{P}}}
  \\
  \tilde{z}
  &= \fn{P} \setminus {\{u, v\}}
\end{align*}

Note that if $\fn{P}$ contains $x$ or $y$,
we have to prevent conflicts by applying a renaming to $P$.

\TODO{3cm}{typing derivation?}


\subsection{Forwarding}

\TODO{2cm}{reason: actor cannot receive on two channels interchangeably}

\TODO{2cm}{idea: sending both $x$ and $y$ to same actor}

\begin{align*}
  \adef*{B_{fw}}{x}{a}{\arcv{x}{i} . \parens{\asnd{a}{x,i} \apar \ains{B_{fw}}{x}{a}}}
\end{align*}

\subsection{Storing Payloads}

\TODO{3cm}{problem: can receive $x$ and $y$ in arbitrary order\\
  receive two $x$s, need to respawn\\
  introduces divergence\\
  we need some storage}

We can use church-encoding to build lists from actors and avoid divergence.

\TODO{2cm}{explain church-encoding}

\begin{align*}
  \adef*{B_{nil}}{l}{}{\arcv{l}{k_n,k_c} . \asnd{k_n}{}}
  \\
  \adef*{B_{cons}}{l}{h,t}{\arcv{l}{k_n,k_c} . \asnd{k_c}{h,t}}
\end{align*}

The actor now receives forwarded messages from both channels $x$ and $y$.
If it receives more messages from one of these channels than from the other,
it stores the excess payloads in a list and remembers from which channel
these came (as there can only be excessive messages on one of these channels).
We again make sure the free names in $P$ do not conflict with any of the names
$a$, $x$, $y$, $f$, $l$, $c$, $p$, $k_n$, $k_c$, $k_P$ and $k_a$,
and define $\tilde{z}$
as the tuple of names in $\fn{P} \setminus {\{u, v\}}$
to give following behavior for the actor.

\begin{align*}
  \adef*{B_a^P}{a}{x,y,f,l,\tilde{z}}{\arcv{a}{c,p} . \anew{k_n}{\anew{k_c}{\anew{k_P}{\anew{k_a}{
  \\ & \hspace{1cm}
    \big(\ \asnd{l}{k_n,k_c}
  \\ & \hspace{1cm}
    \apar \arcv{k_n}{} . \anew{l'}{\parens{\ains{B_{cons}}{l'}{p, l} \apar \asnd{k_a}{c, l'}}}
  \\ & \hspace{1cm}
    \apar \arcv{k_c}{h,t} . \acse*{c}{
    \\ & \hspace{3cm}
      \aalt{f}{\anew{l'}{\parens{\ains{B_{cons}}{l'}{p, l} \apar \asnd{k_a}{f, l'}}}},
    \\ & \hspace{3cm}
      \aalt{x}{\asnd{k_P}{p,h} \apar \asnd{k_a}{f,t}},
    \\ & \hspace{3cm}
      \aalt{y}{\asnd{k_P}{h,p} \apar \asnd{k_a}{f,t}}
    \ }
  \\ & \hspace{1cm}
    \apar \arcv{k_P}{u,v} . \encMJtoAP{P}
  \\ & \hspace{1cm}
    \apar \arcv{k_a}{f',l'} . \ains{B_a^P}{a}{x, y, f', l',\tilde{z}}
  \ \big)
  }}}}} \\
\end{align*}

To encode a \joincalc definition,
we now start one such joining actor (with initially no excess payloads),
a forwarder for each channel
and the encoded subprocess in which the definition is available.

% TODO: free variables of P in parameters
\begin{align*}
  \encMJtoAP{P \jpar Q}
  &= \encMJtoAP{P} \apar \encMJtoAP{Q}
  \\
  \encMJtoAP{\jsnd{x}{y}}
  &= \asnd{x}{y}
  \\
  \encMJtoAP{\jdef{\jrct{\jrcv{x}{u} \jpat \jrcv{y}{v}}{P}}{Q}}
  &= \anew{a}{\anew{x}{\anew{y}{\anew{l}{\\
    &\hspace{1cm}\big(\ \ains{B_a^P}{a}{x, y, x, l} \\
    &\hspace{1cm}\apar \ains{B_{fw}}{x}{a} \apar \ains{B_{fw}}{y}{a} \\
    &\hspace{1cm}\apar \ains{B_{nil}}{l}{} \\
    &\hspace{1cm}\apar \encMJtoAP{Q}
  \ \big)}}}}
\end{align*}

\TODO{4cm}{type correctness\\
  $\judgement{}{}{\encMJtoAP{P}}$ for all core join terms $P$ (by structural induction)\\
  then check type correctness of definitions}

\TODO{4cm}{"operational correspondence"}


\subsection{Full Abstraction}

\TODO{3cm}{join-pi encodings require firewall for full abstraction\\
  (explain why by example?)\\
  this is not necessary here, because ...}
