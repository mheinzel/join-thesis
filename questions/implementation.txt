development process
    ??? what to implement first: full join patterns or locations?
    !!! locations!
    ??? how to test
        XXX

erlang
    ??? what is possible regarding cross-node communication?
        ??? how to send a message to a process on another node?
            !!! Pid is global
        ??? can you move the "current process" to another node?
            !!! not a running process, but function with state, respawn
        XXX
    --- problems with gproc
        --- unregistering self fails
        --- there seem to be problems with nodes joining after gproc application already started???
    --- same version of module needs to be loaded on destination when sending code

process registries
    global
        generally created for few, but long-running processes
        locking to ensure atomic registration -> bottleneck
        conflict resolution features
    pg2
        created for process groups
        locking to ensure atomic registration -> bottleneck
    gproc
        much better performance
        each process can only register itself


fundamentals
    ??? how to represent a channel/name?
        --- Pid of forwarder? (similar to encoding, abstraction)
        --- Pid of common actor + index? (less names to register)
        --- but Pid might change (respawned on different node)
            --- forwarding is inefficient (can create long chain)
            !!! use some kind of ID and ask registry (e.g. gproc) for every send
        XXX
    ??? how is failure handled
        !!! ignore for now
    ??? how to implement parallel operator?
        --- probably using spawn
        --- new processes need to be registered at location
        --- no binary operators, but function taking list of functions (so not evaluated immediately)
        --- syntax could be very noisy, but we could have macros later
    ??? how to do initial exhange of channel names? (e.g. for applets example)
        ??? nameserver of some kind
        XXX
    ??? how parallel is the implementation actually?
        --- all messages on a channel go through the same actor,
            but thath shouldn't be too bad, since you can easily create your own actor
        --- apart from that, everything is pretty independent

distribution
    ??? how to connect nodes initially?
        (add physical locations to level 1 of tree)
        ??? nameserver?
        XXX
    ??? how to send a message to a remote receiver?
        !!! lookup node
            ??? move there (as in theory) or send directly (simpler)?
            XXX
        ??? what if the location just moved to a different machine?
            !!! in the worst case, look it up again, chase it
    ??? how to migrate a process
        !!! implement message asking for state + function,
            send it to another node and spawn
            ??? what if it uses modules that are not present on the other node?
                send all modules to all nodes on connection?
                send modules on-demand?
                ??? what is loaded automatically? erlang? stdlib?
                ??? how to find out when a module is missing?
                !!! distribute own module, ignore rest (for now)
            ??? what about local state/context
                !!! will lose process dictionary etc., but that is lost anyways,
                    since each join pattern firing spawns a new process
            XXX
    ??? how to migrate a location?
        !!! represent location as an actor knowing its sublocations and defs,
            recursively packacke everything up and send to other location
        ??? what happens with processes that are still running?
            !!! just let them run (but DOCUMENT that fact)!
            --- they can do stuff here after the actor started somewhere else already,
            --- violating some reasonable assumptions
        ??? but what about persistent processes that take too long wrapping up?
            !!! the only persistent actors are `actor` and `forward`.
                everything else just sends messages and might be respawned (at new location)
        ??? also, what happens with messages still in the mailbox?
            ??? can we access them and take them with us?
        ??? how do we make sure no messages reach the old Pid?
            !!! keep everything as forwarder until Pid change is propagated
                --- even makes wrapping up mailbox unnecessary
                --- needs to be killed later, otherwise we leak processes
                ??? when to kill it? after n seconds?
                --- problem: when the old process is still alive, the new one cannot register
                    even after calling gproc:goodbye()
                    ??? can we somehow change the registered pid before killing the old actor?
                        otherwise, messages are lost
                    XXX
        ??? how do we find out which location to move when using `go`? (implicit in calculus)
            --- explicit parameter for now? (more flexible, but not true to calculus)
            --- could probably be done using parse_transform (if really necessary)
            --- register location with each actor (cannot change), `go` looks it up
                ??? does that also work for `def`?
                XXX
    ??? which infrastructure is needed?
        !!! global registry (e.g. gproc) with mappings:
            name -> pid of forwarder (or def actor)
            name -> location (if implementing remote sending using `go`)
            location -> pid of location actor
        ??? infrastructure for migrating processes?
            --- there is something by Michal Piotrowksi (github.com/michalwski/proc_mobility)
            --- but it is about migrating processes, not logical units (location tree)
            --- doing it myself should not be too bad
        XXX
    ??? does migration to a different machine require anything else?
        --- e.g. over TCP?
    ??? how to manage the first level locations (physical locations)?
        ??? automatically create and restart?
        XXX

syntax
    ??? how to get it to look nice?
        macros?
        parsetransform?
        --- probably ignore for now
